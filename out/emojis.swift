// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(emojisFFI)
import emojisFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_emojis_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_emojis_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureEmojisInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


/**
 * Data about an emoji.
 */
public struct Emoji {
    /**
     * The emoji character.
     */
    public var emoji: String
    /**
     * The CLDR name of the emoji.
     */
    public var name: String
    /**
     * The Unicode version when this emoji was added.
     */
    public var unicodeVersion: UnicodeVersion
    /**
     * The group this emoji belongs to.
     */
    public var group: Group
    /**
     * Skin tone information about this emoji.
     */
    public var skinTone: SkinToneData?
    /**
     * Shortcodes/aliases for this emoji.
     */
    public var aliases: [String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The emoji character.
         */emoji: String, 
        /**
         * The CLDR name of the emoji.
         */name: String, 
        /**
         * The Unicode version when this emoji was added.
         */unicodeVersion: UnicodeVersion, 
        /**
         * The group this emoji belongs to.
         */group: Group, 
        /**
         * Skin tone information about this emoji.
         */skinTone: SkinToneData?, 
        /**
         * Shortcodes/aliases for this emoji.
         */aliases: [String]?) {
        self.emoji = emoji
        self.name = name
        self.unicodeVersion = unicodeVersion
        self.group = group
        self.skinTone = skinTone
        self.aliases = aliases
    }
}

#if compiler(>=6)
extension Emoji: Sendable {}
#endif


extension Emoji: Equatable, Hashable {
    public static func ==(lhs: Emoji, rhs: Emoji) -> Bool {
        if lhs.emoji != rhs.emoji {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.unicodeVersion != rhs.unicodeVersion {
            return false
        }
        if lhs.group != rhs.group {
            return false
        }
        if lhs.skinTone != rhs.skinTone {
            return false
        }
        if lhs.aliases != rhs.aliases {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(emoji)
        hasher.combine(name)
        hasher.combine(unicodeVersion)
        hasher.combine(group)
        hasher.combine(skinTone)
        hasher.combine(aliases)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEmoji: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Emoji {
        return
            try Emoji(
                emoji: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                unicodeVersion: FfiConverterTypeUnicodeVersion.read(from: &buf), 
                group: FfiConverterTypeGroup.read(from: &buf), 
                skinTone: FfiConverterOptionTypeSkinToneData.read(from: &buf), 
                aliases: FfiConverterOptionSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: Emoji, into buf: inout [UInt8]) {
        FfiConverterString.write(value.emoji, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeUnicodeVersion.write(value.unicodeVersion, into: &buf)
        FfiConverterTypeGroup.write(value.group, into: &buf)
        FfiConverterOptionTypeSkinToneData.write(value.skinTone, into: &buf)
        FfiConverterOptionSequenceString.write(value.aliases, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmoji_lift(_ buf: RustBuffer) throws -> Emoji {
    return try FfiConverterTypeEmoji.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmoji_lower(_ value: Emoji) -> RustBuffer {
    return FfiConverterTypeEmoji.lower(value)
}


/**
 * Data about skin tone variants for an emoji.
 */
public struct SkinToneData {
    /**
     * Index of the first skin tone variant in the EMOJIS array
     */
    public var first: UInt16
    /**
     * Number of skin tone variants
     */
    public var second: UInt8
    /**
     * The skin tone of this emoji
     */
    public var tone: SkinTone

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Index of the first skin tone variant in the EMOJIS array
         */first: UInt16, 
        /**
         * Number of skin tone variants
         */second: UInt8, 
        /**
         * The skin tone of this emoji
         */tone: SkinTone) {
        self.first = first
        self.second = second
        self.tone = tone
    }
}

#if compiler(>=6)
extension SkinToneData: Sendable {}
#endif


extension SkinToneData: Equatable, Hashable {
    public static func ==(lhs: SkinToneData, rhs: SkinToneData) -> Bool {
        if lhs.first != rhs.first {
            return false
        }
        if lhs.second != rhs.second {
            return false
        }
        if lhs.tone != rhs.tone {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(first)
        hasher.combine(second)
        hasher.combine(tone)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSkinToneData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SkinToneData {
        return
            try SkinToneData(
                first: FfiConverterUInt16.read(from: &buf), 
                second: FfiConverterUInt8.read(from: &buf), 
                tone: FfiConverterTypeSkinTone.read(from: &buf)
        )
    }

    public static func write(_ value: SkinToneData, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.first, into: &buf)
        FfiConverterUInt8.write(value.second, into: &buf)
        FfiConverterTypeSkinTone.write(value.tone, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSkinToneData_lift(_ buf: RustBuffer) throws -> SkinToneData {
    return try FfiConverterTypeSkinToneData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSkinToneData_lower(_ value: SkinToneData) -> RustBuffer {
    return FfiConverterTypeSkinToneData.lower(value)
}


/**
 * A Unicode version.
 */
public struct UnicodeVersion {
    public var major: UInt32
    public var minor: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(major: UInt32, minor: UInt32) {
        self.major = major
        self.minor = minor
    }
}

#if compiler(>=6)
extension UnicodeVersion: Sendable {}
#endif


extension UnicodeVersion: Equatable, Hashable {
    public static func ==(lhs: UnicodeVersion, rhs: UnicodeVersion) -> Bool {
        if lhs.major != rhs.major {
            return false
        }
        if lhs.minor != rhs.minor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(major)
        hasher.combine(minor)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnicodeVersion: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnicodeVersion {
        return
            try UnicodeVersion(
                major: FfiConverterUInt32.read(from: &buf), 
                minor: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: UnicodeVersion, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.major, into: &buf)
        FfiConverterUInt32.write(value.minor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnicodeVersion_lift(_ buf: RustBuffer) throws -> UnicodeVersion {
    return try FfiConverterTypeUnicodeVersion.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnicodeVersion_lower(_ value: UnicodeVersion) -> RustBuffer {
    return FfiConverterTypeUnicodeVersion.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A category for an emoji.
 *
 * Based on Unicode CLDR data.
 */

public enum Group {
    
    case smileysAndEmotion
    case peopleAndBody
    case animalsAndNature
    case foodAndDrink
    case travelAndPlaces
    case activities
    case objects
    case symbols
    case flags
}


#if compiler(>=6)
extension Group: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGroup: FfiConverterRustBuffer {
    typealias SwiftType = Group

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Group {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .smileysAndEmotion
        
        case 2: return .peopleAndBody
        
        case 3: return .animalsAndNature
        
        case 4: return .foodAndDrink
        
        case 5: return .travelAndPlaces
        
        case 6: return .activities
        
        case 7: return .objects
        
        case 8: return .symbols
        
        case 9: return .flags
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Group, into buf: inout [UInt8]) {
        switch value {
        
        
        case .smileysAndEmotion:
            writeInt(&buf, Int32(1))
        
        
        case .peopleAndBody:
            writeInt(&buf, Int32(2))
        
        
        case .animalsAndNature:
            writeInt(&buf, Int32(3))
        
        
        case .foodAndDrink:
            writeInt(&buf, Int32(4))
        
        
        case .travelAndPlaces:
            writeInt(&buf, Int32(5))
        
        
        case .activities:
            writeInt(&buf, Int32(6))
        
        
        case .objects:
            writeInt(&buf, Int32(7))
        
        
        case .symbols:
            writeInt(&buf, Int32(8))
        
        
        case .flags:
            writeInt(&buf, Int32(9))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroup_lift(_ buf: RustBuffer) throws -> Group {
    return try FfiConverterTypeGroup.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroup_lower(_ value: Group) -> RustBuffer {
    return FfiConverterTypeGroup.lower(value)
}


extension Group: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The skin tone of an emoji.
 */

public enum SkinTone {
    
    case `default`
    case light
    case mediumLight
    case medium
    case mediumDark
    case dark
    case lightAndMediumLight
    case lightAndMedium
    case lightAndMediumDark
    case lightAndDark
    case mediumLightAndLight
    case mediumLightAndMedium
    case mediumLightAndMediumDark
    case mediumLightAndDark
    case mediumAndLight
    case mediumAndMediumLight
    case mediumAndMediumDark
    case mediumAndDark
    case mediumDarkAndLight
    case mediumDarkAndMediumLight
    case mediumDarkAndMedium
    case mediumDarkAndDark
    case darkAndLight
    case darkAndMediumLight
    case darkAndMedium
    case darkAndMediumDark
}


#if compiler(>=6)
extension SkinTone: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSkinTone: FfiConverterRustBuffer {
    typealias SwiftType = SkinTone

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SkinTone {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`default`
        
        case 2: return .light
        
        case 3: return .mediumLight
        
        case 4: return .medium
        
        case 5: return .mediumDark
        
        case 6: return .dark
        
        case 7: return .lightAndMediumLight
        
        case 8: return .lightAndMedium
        
        case 9: return .lightAndMediumDark
        
        case 10: return .lightAndDark
        
        case 11: return .mediumLightAndLight
        
        case 12: return .mediumLightAndMedium
        
        case 13: return .mediumLightAndMediumDark
        
        case 14: return .mediumLightAndDark
        
        case 15: return .mediumAndLight
        
        case 16: return .mediumAndMediumLight
        
        case 17: return .mediumAndMediumDark
        
        case 18: return .mediumAndDark
        
        case 19: return .mediumDarkAndLight
        
        case 20: return .mediumDarkAndMediumLight
        
        case 21: return .mediumDarkAndMedium
        
        case 22: return .mediumDarkAndDark
        
        case 23: return .darkAndLight
        
        case 24: return .darkAndMediumLight
        
        case 25: return .darkAndMedium
        
        case 26: return .darkAndMediumDark
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SkinTone, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`default`:
            writeInt(&buf, Int32(1))
        
        
        case .light:
            writeInt(&buf, Int32(2))
        
        
        case .mediumLight:
            writeInt(&buf, Int32(3))
        
        
        case .medium:
            writeInt(&buf, Int32(4))
        
        
        case .mediumDark:
            writeInt(&buf, Int32(5))
        
        
        case .dark:
            writeInt(&buf, Int32(6))
        
        
        case .lightAndMediumLight:
            writeInt(&buf, Int32(7))
        
        
        case .lightAndMedium:
            writeInt(&buf, Int32(8))
        
        
        case .lightAndMediumDark:
            writeInt(&buf, Int32(9))
        
        
        case .lightAndDark:
            writeInt(&buf, Int32(10))
        
        
        case .mediumLightAndLight:
            writeInt(&buf, Int32(11))
        
        
        case .mediumLightAndMedium:
            writeInt(&buf, Int32(12))
        
        
        case .mediumLightAndMediumDark:
            writeInt(&buf, Int32(13))
        
        
        case .mediumLightAndDark:
            writeInt(&buf, Int32(14))
        
        
        case .mediumAndLight:
            writeInt(&buf, Int32(15))
        
        
        case .mediumAndMediumLight:
            writeInt(&buf, Int32(16))
        
        
        case .mediumAndMediumDark:
            writeInt(&buf, Int32(17))
        
        
        case .mediumAndDark:
            writeInt(&buf, Int32(18))
        
        
        case .mediumDarkAndLight:
            writeInt(&buf, Int32(19))
        
        
        case .mediumDarkAndMediumLight:
            writeInt(&buf, Int32(20))
        
        
        case .mediumDarkAndMedium:
            writeInt(&buf, Int32(21))
        
        
        case .mediumDarkAndDark:
            writeInt(&buf, Int32(22))
        
        
        case .darkAndLight:
            writeInt(&buf, Int32(23))
        
        
        case .darkAndMediumLight:
            writeInt(&buf, Int32(24))
        
        
        case .darkAndMedium:
            writeInt(&buf, Int32(25))
        
        
        case .darkAndMediumDark:
            writeInt(&buf, Int32(26))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSkinTone_lift(_ buf: RustBuffer) throws -> SkinTone {
    return try FfiConverterTypeSkinTone.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSkinTone_lower(_ value: SkinTone) -> RustBuffer {
    return FfiConverterTypeSkinTone.lower(value)
}


extension SkinTone: Equatable, Hashable {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeEmoji: FfiConverterRustBuffer {
    typealias SwiftType = Emoji?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEmoji.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEmoji.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSkinToneData: FfiConverterRustBuffer {
    typealias SwiftType = SkinToneData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSkinToneData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSkinToneData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEmoji: FfiConverterRustBuffer {
    typealias SwiftType = [Emoji]

    public static func write(_ value: [Emoji], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEmoji.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Emoji] {
        let len: Int32 = try readInt(&buf)
        var seq = [Emoji]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEmoji.read(from: &buf))
        }
        return seq
    }
}
/**
 * Lookup an emoji by Unicode value.
 *
 * This take *Ο(1)* time.
 *
 * # Note
 *
 * If passed a minimally qualified or unqualified emoji this will return the
 * emoji struct containing the fully qualified version.
 *
 * # Examples
 *
 * In the ordinary case.
 *
 * ```
 * let emoji = "🚀";
 * let rocket = emojis::get(emoji).unwrap();
 * assert!(rocket.as_str() == emoji);
 * assert_eq!(rocket.shortcode().unwrap(), "rocket");
 * ```
 *
 * For a minimally qualified or unqualified emoji.
 *
 * ```
 * let unqualified = "\u{1f43f}";
 * let fully_qualified = "\u{1f43f}\u{fe0f}";
 * let chipmunk = emojis::get(unqualified).unwrap();
 * assert_eq!(chipmunk.as_str(), fully_qualified);
 * assert_eq!(chipmunk.shortcode().unwrap(), "chipmunk");
 * ```
 */
public func get(s: String) -> Emoji?  {
    return try!  FfiConverterOptionTypeEmoji.lift(try! rustCall() {
    uniffi_emojis_fn_func_get(
        FfiConverterString.lower(s),$0
    )
})
}
public func skinTones(emoji: Emoji) -> [Emoji]  {
    return try!  FfiConverterSequenceTypeEmoji.lift(try! rustCall() {
    uniffi_emojis_fn_func_skin_tones(
        FfiConverterTypeEmoji_lower(emoji),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_emojis_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_emojis_checksum_func_get() != 194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_emojis_checksum_func_skin_tones() != 43373) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureEmojisInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all